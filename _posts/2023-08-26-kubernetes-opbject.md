---
layout: post
title: "쿠버네티스 오브젝트"
date: 2023-08-26
excerpt: "쿠버네티스의 모든 오브젝트에 대한 개념 정리"
tags: [kubernetes, backend]
comments: true
---

이 글에서는 크게 3가지에 대해 정리한다. 

1. 쿠버네티스 오브젝트의 yaml 구조를 이해한다. 
2. kubectl로 오브젝트를 다룬다. 
3. 서비스를 이루는 오브젝트간의 관계를 이해한다. 

----

## 쿠버네트스 오브젝트란?

쿠버네티스에서 오브젝트는 '하나의 의도를 담은 레코드'를 의미한다. 

예를 들어 어떤 컨테이너화된 어플리케이션이 몇개로 다중화되어서 컨테이너를 띄울지, CPU 몇개를 할당할지, 배포는 어떤 전략으로 진행할지와 같은 수많은 구성요소들을 사용자가 정의한 '레코드'의 형태를 띄는 것이다. 

사용자가 쿠버네티스의 워커 노드를 어떤식으로 운영할지 결졍하기 위해, 오브젝트를 어떤 의도를 가지고 생성할지 쿠버네티스에 전달한다고 볼 수 있다. 

* 오브젝트 생성

오브젝트에 대한 기본적인 정보와 의도한 상태를 기술한 오브젝트 스팩을 제시할 수 있다. 오브젝트 생성을 위한 쿠버네티스 API 요청은 JSON 형식 정보를 포함한다. 대부분의 경우 정보를 yaml 파일로 kubectl에 제공한다. 

```shell
# kubectl을 사용해 쿠버네티스에 오브젝트 생성 요청을 전달한다. 
$ kubectl apply -f deployment.yaml
```

예시) service 오브젝트 생성

```yml
apiVersion : v1
kind: Service
metadata: 
    name: mytest-service
    ports: 
        - targetPort: 80
          port: 80
          NodePort: 30008
```

* yaml의 기본 구조
    * apiVersion (string)
        * 어떤 오브젝트를 만드냐에 따라 정해진 값이 다르다. 
        * 예를들어 Service 오브젝트는 v1, Deployment 오브젝트는 apps/v1을 기술한다. 
    * kind (string)
        * 만들고자 하는 오브젝트의 종류
    * metadata (dictionary)
        * 오브젝트에 부여할 이름이나 기타 메타 데이터를 기술
    * spec (dictionary)
        * 만들고자 하는 오브젝트에 따라 '의도한 상태'를 기술
    * status (dictionary)
        * 사람이 아니라 시스템에 의해 기술되는 부분으로 오브젝트의 '실제 상태'를 기술한다. 
        * 쿠버네티스 컨트롤 플레인은 **오브젝트의 실제 상태를 의도한 상태에 일치시키는 방향으로 동작한다.** 
        * 예를들어 사용자가 파드의 개수를 2개에서 4개로 yaml 파일을 변경한다면 순간적으로 사용자가 정의한 spec부분과 쿠버네티스가 관리하는 status 정보가 어긋날 수 있다. 그럼 쿠버네티스는 다시 spec부분에 기술된 내용으로 status를 변경한다. 


----

## node(Worker node)

노드는 오브젝트라고 보기에는 예외적인 리소스이다. 그 이유는 쿠버네티스 클러스터를 만들때 같이 만들어지는 자원으로 사용자가 yaml로 따로 생성할 필요가 없기 때문이다. 

데이터 플레인의 워커 노드를 의미하고 워크 로드가 돌아가는 컨테이너를 배치하는 물리 혹은 가상머신이고 컨트롤 플레인에 의해 관리된다. 

minikube 같은 경우는 노드가 하나 만있었지만 실제로는 여러 노드로 구성하고, 각 노드는 kubelet, container-runtime, kube-proxy가 포함되어 있다. 




